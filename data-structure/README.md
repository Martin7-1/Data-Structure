# 数据结构复习

> 本仓库是南京大学软件学院大二课程《数据结构与算法》的一个复习仓库
> 非官方！请注意不要商用和非法使用！

## 概述

目前本仓库收录的课程内容有

1. 图(Graph)
2. 线性表
3. 树

## 1. 图

### 1.1 最小生成树

### 1.1.1 什么是最小生成树

生成树（spanning tree）指的是给定一个**连通无向图**，通过 n-1 条边将所有的顶点连起来（顶点的个数为 n）。
这样形成的图是原图我的一个子图，而且是一棵树。

如果该图是有权重的，那么**最小生成树（Minimum Spanning Tree）**指的是将所有点连接起来的边的权重之和最小。常见的
寻找最小生成树的算法有以下两种：

1. Kruskal算法
2. Prim算法

两个算法都用了**贪心**的思想，即在当前步骤选择最优解，贪心思想的困难在于如何去证明它的正确性，这里我们不阐述。

#### 1.1.2 Kruskal算法

1. 按权重的非递减顺序对所有边进行排序。 
2. 选取最小的边。检查它是否与到目前为止形成的生成树形成一个循环。如果未形成环，则包括此边。否则，丢弃它。 
3. 重复步骤2，直到生成树中有(V-1)条边。

#### 1.1.3 Prim算法

它从一棵空的生成树开始。这个想法是维护两组顶点。第一组包含已包含在 MST 中的顶点，另一组包含尚未包含的顶点。在每一步，它都会考虑连接这两个集合的所有边，并从这些边中挑选出权重最小的边。拾取边后，它将边的另一个端点移动到包含 MST 的集合中。


## 2. 线性表

### 2.1 链表实现的线性表

#### 2.1.1 约瑟夫问题

约瑟夫问题指的是人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

该问题的解法可以通过使用循环线性表来实现模拟。每次删除对应的人，重复 n-1 次(假设有n个人)即可

#### 2.1.2 多项式问题

## 3. 树

### 3.1 二叉树

#### 3.1.1 二叉树的遍历

二叉树的遍历其实是深度优先搜索(Depth First Search, DFS) 和 广度优先搜索(Breath First Search) 的应用，前者主要是前序遍历，中序遍历和
后序遍历，后者主要是层级遍历。前序遍历、中序遍历、后序遍历可以看成我们先沿着某一条路径(这里是图的概念)走到树的叶子节点，然后再通过回溯
来进行另一条路径的遍历。具体实现的时候，前三种遍历可以用递归来进行实现，也可以用栈来消除递归带来的时间复杂度影响。最后一种则是一个典型
的队列的应用，我们需要将某一层节点的子节点全部遍历完了之后才能够前往下一层，很明显这是一种FIFO(First In Last Out)的结构，即对每一个我
们遍历到的节点，我们都应该将其子节点加入到队列当中。

#### 3.1.1.1 前序遍历

下面我们讨论的遍历都是先左后右的结构，即我们都是先遍历左子树再遍历右子树。前序遍历指的是先遍历树(和子树)的根节点，然后再遍历其左子树
，然后再遍历右子树。可以很容易的用递归写法写出

```java
private void preorderTraverse(BinaryNode<T> node, List<T> list) {
        if (node == null) {
            return;
        }

        list.add(node.element);
        preorderTraverse(node.left, list);
        preorderTraverse(node.right, list);
    }
```

#### 3.1.1.2 中序遍历


#### 3.1.1.3 后序遍历


#### 3.1.1.4 层级遍历

### 3.2 m-路搜索树

> m-路搜索树是B-Tree的一个基础

#### 3.2.1 m-路搜索树的性质

1. m-路搜索树的内节点最多有m个子节点，节点内最多有m-1个关键码，且这些关键码按大小排列
2. 有 $p$ 个关键码节点一定会有 $p+1$ 个子节点
3. m-路搜索树的一个节点可以表示成如下的形式
	* $C_0k_1C_1k_2 \dots k_pC_p$
	* 其中 $C_0$ 是一个指向子节点的指针，且其中的值要全部小于 $k_1$
	* $C_i$ 指向的子节点的值需要全部大于 $k_i$ 且全部小于 $k_{i+1}$
	* $C_p$ 指向的子节点的值需要全部大于 $k_p$ 里的值 

#### 3.2.2 m-路搜索树的查找

思路：和二叉搜索树相同，但在某个节点里我们需要遍历到前一个关键码小于要搜索的值，后一个关键码大于要搜索的值，然后在两个关键码之间的子节点继续递归搜索，直到我们搜索到外部节点或者我们找到了该节点

#### 3.2.3 m-路搜索树的插入

思路：同理，我们需要遍历到前一个关键码小雨要插入的值，后一个关键码大于要搜索的值，然后在两个关键码之间的子节点继续递归向下到叶节点，如果叶节点的关键码数量没满 $m$，那么我们直接插入即可

如果叶节点的关键码数量已经是 $m$ 了，那么我们可以将该节点的中间值拉到父节点，然后将该节点拆成两半，如果父节点的关键码也已经满了（即我们没办法将该该节点的中间拉到父节点），那么我们应该先处理父节点，现将父节点的中间值拉到父节点的父节点，然后分裂，即我们应该如此递归下去。这种做法在后面B-Tree的插入中也是十分常见的，这也是B-Tree唯一有可能增加树高的方式，请注意，B-Tree增加树高是自底向上的，即增加树高的方式是根节点再一次往上拉取一个节点，导致高度加一。

同时我们需要注意，m-路搜索树并不一定要求所有外部节点在同一层，这意味着当某个叶子节点已经满了之后，我们可以通过增加子节点来存放新的节点，而不是用上面这种"分裂"的方式。（也就是上面这种分裂的方式其实是下面所要讨论的B-Tree的删除方式）

#### 3.2.4 m-路搜索树的删除

思路：直接删除即可，如果不是删除叶子节点，我们和二叉搜索树一样，也需要从其左边指针的子树中找到一个值最大的节点替代当前节点，然后删除那个节点即可。对于某个删除后空出来的节点或因为上述操作移动而导致空出来的节点，我们需要同理找到左指针指向的子树中值最小或者右指针指向的子树中值最大的值来替换，如此递归到叶子节点即可。注意：m-路搜索树的删除如果导致某个外部节点的消失并不影响。
    

### 3.3 B树

#### 3.3.1 B树的性质

1. B-Tree的所有叶子节点都在同一层
2. B-Tree有"阶"的定义，几阶限定了B-Tree的每个节点里关键码的数量和外节点的数量
3. 除了树根的其他节点必须要包含至少 $t/2 - 1$ 个关键码（key），这里的 $t$ 是B-Tree的阶数，除法需要向上取整，即每个节点至少要包含 $t/2$ 个子节点（根节点除外）
4. 同时B-Tree也是一个m-路搜索树，也就是说每个节点中的关键码个数不能多于m（在B-Tree中用阶来定义）
5. 根节点至少有两个子节点
6. 外部节点的个数 = 关键码个数 + 1

#### 3.3.2 B-Tree的查找

思路：与m-路搜索树相同，我们只需要找到前一个关键码的值小于我们要搜索的值，后一个关键码的值大雨我们要搜索的值，两个值中间的指针指向的子节点就是我们要前往下一层的节点，然后递归的寻找即可。时间复杂度为 $O(h)$，h为B-Tree的高度。在磁盘中，由于B-Tree的"fat"，这个高度不会很高

关于B-Tree的高度：

#### 3.3.3 B—Tree的插入

B—Tree的插入永远发生在位于外部节点上一层的节点中，且有以下几种情况发生

1. 要插入的节点中关键码的数量小于 $m-1$，按大小排序直接插入该节点即可
2. 要插入的节点中关键码的数量等于 $m$，则我们需要将当前节点进行一个分裂，并将 $k_{\frac{m}{2}}$ 的关键码拉到父节点（这里的除法是 $m/2$ 向上取整）。如果父节点的关键码也满了，那么我们就递归分裂并向上移动关键码。
3. 如果root的关键码也是满的，那么这样递归向上会造成**B—Tree的高度加一**，这也是唯一的能够增加B-Tree高度的方式。当然，思考之后我们就会知道，其实能够到如此地步的概率一般是十分小的，在真实磁盘中的B-Tree的阶数一般都十分的大，即分裂一次之后我们可以在新的节点中存储很多的节点，因此不太有可能造成B—Tree的高度增加。即使高度增加了，那么下一次增加肯定会发生很久以后，因为此时我们有很多分裂的节点可以让我们插入新的节点。
4. ![](https://s2.loli.net/2021/12/24/1ar9AizCdyStoJ3.png)
2. ![](https://s2.loli.net/2021/12/24/QDoJLerMzvgCBa5.png)

节点的插入最多引起的磁盘访问量是 $h + 2s + 1$，h是树高，s是分裂的节点数量（需要写入分裂后的节点到磁盘），剩下1是写入新的节点

#### 3.3.4 B-Tree的删除

B-Tree的删除有两种情况：

1. 删除的关键码所在节点的子节点是一个外部节点，即删除的关键码在叶子节点中
2. 删除的关键码所在节点不是叶节点。

##### 3.3.4.1 Case 1（删除的关键码的子节点是一个外部节点）

1. 若删除该关键码之后该节点的关键码个数仍然大于 $\frac{m}{2} - 1$（这里的除法要向上取整），那么我们就直接删除该关键码即可

2. 如果不满足上述的情况，那么又可以分出两种情况：

	* 那么我们需要进行一个"借"的操作。对于一个关键码个数刚好是 $\frac{m}{2} - 1$的节点进行删除，我们可以向邻居借关键码，并进行一定的调整。

	* 调整方式：比如下图，需要从左边的邻居借一个关键码，将关键码**提到**父节点中，然后将父节点的关键码**下拉**到该节点中。

		![](https://s2.loli.net/2021/12/24/9hl53VFeWmD7X86.png)

	* 如果邻居节点也都只有 $\frac{m}{2} - 1$（除法向上取证）个节点，那么我们需要再删除之后合并两个子节点，而且将父节点在这两个子节点的指针之间的关键码**下拉**到子节点中。

	* 这样做有可能会在父节点造成新的合并（当下拉之后父节点与其邻居都不满足关键码数量至少有$\frac{m}{2} - 1$（除法向上取整）时 ），然后不断递归向上合并，最后有可能合并到根节点，此时B-Tree的**树高会减少一**

	* ![](https://s2.loli.net/2021/12/24/d2v36gSLW5Q9XbV.jpg)

##### 3.3.4.2 Case 2



