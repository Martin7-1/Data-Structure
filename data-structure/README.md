# 数据结构复习
> 本仓库是南京大学软件学院大二课程《数据结构与算法》的一个复习仓库
> 非官方！请注意不要商用和非法使用！


## 概述
目前本仓库收录的课程内容有

1. 图(Graph)
2. 线性表
3. 树

## 1. 图

### 1.1 最小生成树
-
### 1.1.1 什么是最小生成树

生成树（spanning tree）指的是给定一个**连通无向图**，通过 n-1 条边将所有的顶点连起来（顶点的个数为 n）。
这样形成的图是原图我的一个子图，而且是一棵树。

如果该图是有权重的，那么**最小生成树（Minimum Spanning Tree）**指的是将所有点连接起来的边的权重之和最小。常见的
寻找最小生成树的算法有以下两种：

1. Kruskal算法
2. Prim算法

两个算法都用了**贪心**的思想，即在当前步骤选择最优解，贪心思想的困难在于如何去证明它的正确性，这里我们不阐述。

#### 1.1.2 Kruskal算法

1. 按权重的非递减顺序对所有边进行排序。 
2. 选取最小的边。检查它是否与到目前为止形成的生成树形成一个循环。如果未形成环，则包括此边。否则，丢弃它。 
3. 重复步骤2，直到生成树中有(V-1)条边。

#### 1.1.3 Prim算法

它从一棵空的生成树开始。这个想法是维护两组顶点。第一组包含已包含在 MST 中的顶点，另一组包含尚未包含的顶点。在每一步，它都会考虑连接这两个集合的所有边，并从这些边中挑选出权重最小的边。拾取边后，它将边的另一个端点移动到包含 MST 的集合中。


## 2. 线性表

### 2.1 链表实现的线性表

#### 2.1.1 约瑟夫问题

约瑟夫问题指的是人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

该问题的解法可以通过使用循环线性表来实现模拟。每次删除对应的人，重复 n-1 次(假设有n个人)即可

#### 2.1.2 多项式问题

## 3. 树

### 3.1 二叉树

#### 3.1.1 二叉树的遍历

二叉树的遍历其实是深度优先搜索(Depth First Search, DFS) 和 广度优先搜索(Breath First Search) 的应用，前者主要是前序遍历，中序遍历和
后序遍历，后者主要是层级遍历。前序遍历、中序遍历、后序遍历可以看成我们先沿着某一条路径(这里是图的概念)走到树的叶子节点，然后再通过回溯
来进行另一条路径的遍历。具体实现的时候，前三种遍历可以用递归来进行实现，也可以用栈来消除递归带来的时间复杂度影响。最后一种则是一个典型
的队列的应用，我们需要将某一层节点的子节点全部遍历完了之后才能够前往下一层，很明显这是一种FIFO(First In Last Out)的结构，即对每一个我
们遍历到的节点，我们都应该将其子节点加入到队列当中。

#### 3.1.1.1 前序遍历

下面我们讨论的遍历都是先左后右的结构，即我们都是先遍历左子树再遍历右子树。前序遍历指的是先遍历树(和子树)的根节点，然后再遍历其左子树
，然后再遍历右子树。可以很容易的用递归写法写出

```java
private void preorderTraverse(BinaryNode<T> node, List<T> list) {
        if (node == null) {
            return;
        }

        list.add(node.element);
        preorderTraverse(node.left, list);
        preorderTraverse(node.right, list);
    }
```

#### 3.1.1.2 中序遍历


#### 3.1.1.3 后序遍历


#### 3.1.1.4 层级遍历