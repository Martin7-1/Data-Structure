# 数据结构复习

> 本仓库是南京大学软件学院大二课程《数据结构与算法》的一个复习仓库
> 非官方！请注意不要商用和非法使用！

## 概述

目前本仓库收录的课程内容有

1. 图(Graph)
2. 线性表
3. 树
3. 优先级队列/堆
3. 栈和队列

## 1. 图

### 1.1 最小生成树

### 1.1.1 什么是最小生成树

生成树（spanning tree）指的是给定一个**连通无向图**，通过 n-1 条边将所有的顶点连起来（顶点的个数为 n）。
这样形成的图是原图我的一个子图，而且是一棵树。

如果该图是有权重的，那么**最小生成树（Minimum Spanning Tree）**指的是将所有点连接起来的边的权重之和最小。常见的
寻找最小生成树的算法有以下两种：

1. Kruskal算法
2. Prim算法

两个算法都用了**贪心**的思想，即在当前步骤选择最优解，贪心思想的困难在于如何去证明它的正确性，这里我们不阐述。

#### 1.1.2 Kruskal算法

1. 按权重的非递减顺序对所有边进行排序。 
2. 选取最小的边。检查它是否与到目前为止形成的生成树形成一个循环。如果未形成环，则包括此边。否则，丢弃它。 
3. 重复步骤2，直到生成树中有(V-1)条边。

#### 1.1.3 Prim算法

它从一棵空的生成树开始。这个想法是维护两组顶点。第一组包含已包含在 MST 中的顶点，另一组包含尚未包含的顶点。在每一步，它都会考虑连接这两个集合的所有边，并从这些边中挑选出权重最小的边。拾取边后，它将边的另一个端点移动到包含 MST 的集合中。


## 2. 线性表

### 2.1 链表实现的线性表

#### 2.1.1 约瑟夫问题

约瑟夫问题指的是人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

该问题的解法可以通过使用循环线性表来实现模拟。每次删除对应的人，重复 n-1 次(假设有n个人)即可

#### 2.1.2 多项式问题

## 3. 树

### 3.1 二叉树

#### 3.1.1 二叉树的遍历

二叉树的遍历其实是深度优先搜索(Depth First Search, DFS) 和 广度优先搜索(Breath First Search) 的应用，前者主要是前序遍历，中序遍历和
后序遍历，后者主要是层级遍历。前序遍历、中序遍历、后序遍历可以看成我们先沿着某一条路径(这里是图的概念)走到树的叶子节点，然后再通过回溯
来进行另一条路径的遍历。具体实现的时候，前三种遍历可以用递归来进行实现，也可以用栈来消除递归带来的时间复杂度影响。最后一种则是一个典型
的队列的应用，我们需要将某一层节点的子节点全部遍历完了之后才能够前往下一层，很明显这是一种FIFO(First In Last Out)的结构，即对每一个我
们遍历到的节点，我们都应该将其子节点加入到队列当中。

#### 3.1.1.1 前序遍历

下面我们讨论的遍历都是先左后右的结构，即我们都是先遍历左子树再遍历右子树。前序遍历指的是先遍历树(和子树)的根节点，然后再遍历其左子树
，然后再遍历右子树。可以很容易的用递归写法写出

```java
private void preorderTraverse(BinaryNode<T> node, List<T> list) {
        if (node == null) {
            return;
        }

        list.add(node.element);
        preorderTraverse(node.left, list);
        preorderTraverse(node.right, list);
    }
```

#### 3.1.1.2 中序遍历


#### 3.1.1.3 后序遍历


#### 3.1.1.4 层级遍历

### 3.2 m-路搜索树

> m-路搜索树是B-Tree的一个基础

#### 3.2.1 m-路搜索树的性质

1. m-路搜索树的内节点最多有m个子节点，节点内最多有m-1个关键码，且这些关键码按大小排列
2. 有 $p$ 个关键码节点一定会有 $p+1$ 个子节点
3. m-路搜索树的一个节点可以表示成如下的形式
	* $C_0k_1C_1k_2 \dots k_pC_p$
	* 其中 $C_0$ 是一个指向子节点的指针，且其中的值要全部小于 $k_1$
	* $C_i$ 指向的子节点的值需要全部大于 $k_i$ 且全部小于 $k_{i+1}$
	* $C_p$ 指向的子节点的值需要全部大于 $k_p$ 里的值 

#### 3.2.2 m-路搜索树的查找

思路：和二叉搜索树相同，但在某个节点里我们需要遍历到前一个关键码小于要搜索的值，后一个关键码大于要搜索的值，然后在两个关键码之间的子节点继续递归搜索，直到我们搜索到外部节点或者我们找到了该节点

#### 3.2.3 m-路搜索树的插入

思路：同理，我们需要遍历到前一个关键码小雨要插入的值，后一个关键码大于要搜索的值，然后在两个关键码之间的子节点继续递归向下到叶节点，如果叶节点的关键码数量没满 $m$，那么我们直接插入即可

如果叶节点的关键码数量已经是 $m$ 了，那么我们可以将该节点的中间值拉到父节点，然后将该节点拆成两半，如果父节点的关键码也已经满了（即我们没办法将该该节点的中间拉到父节点），那么我们应该先处理父节点，现将父节点的中间值拉到父节点的父节点，然后分裂，即我们应该如此递归下去。这种做法在后面B-Tree的插入中也是十分常见的，这也是B-Tree唯一有可能增加树高的方式，请注意，B-Tree增加树高是自底向上的，即增加树高的方式是根节点再一次往上拉取一个节点，导致高度加一。

同时我们需要注意，m-路搜索树并不一定要求所有外部节点在同一层，这意味着当某个叶子节点已经满了之后，我们可以通过增加子节点来存放新的节点，而不是用上面这种"分裂"的方式。（也就是上面这种分裂的方式其实是下面所要讨论的B-Tree的删除方式）

#### 3.2.4 m-路搜索树的删除

思路：直接删除即可，如果不是删除叶子节点，我们和二叉搜索树一样，也需要从其左边指针的子树中找到一个值最大的节点替代当前节点，然后删除那个节点即可。对于某个删除后空出来的节点或因为上述操作移动而导致空出来的节点，我们需要同理找到左指针指向的子树中值最小或者右指针指向的子树中值最大的值来替换，如此递归到叶子节点即可。注意：m-路搜索树的删除如果导致某个外部节点的消失并不影响。
    

### 3.3 B树

#### 3.3.1 B树的性质

1. B-Tree的所有叶子节点都在同一层
2. B-Tree有"阶"的定义，几阶限定了B-Tree的每个节点里关键码的数量和外节点的数量
3. 除了树根的其他节点必须要包含至少 $t/2 - 1$ 个关键码（key），这里的 $t$ 是B-Tree的阶数，除法需要向上取整，即每个节点至少要包含 $t/2$ 个子节点（根节点除外）
4. 同时B-Tree也是一个m-路搜索树，也就是说每个节点中的关键码个数不能多于m（在B-Tree中用阶来定义）
5. 根节点至少有两个子节点
6. 外部节点的个数 = 关键码个数 + 1

#### 3.3.2 B-Tree的查找

思路：与m-路搜索树相同，我们只需要找到前一个关键码的值小于我们要搜索的值，后一个关键码的值大雨我们要搜索的值，两个值中间的指针指向的子节点就是我们要前往下一层的节点，然后递归的寻找即可。时间复杂度为 $O(h)$，h为B-Tree的高度。在磁盘中，由于B-Tree的"fat"，这个高度不会很高

关于B-Tree的高度：

#### 3.3.3 B—Tree的插入

B—Tree的插入永远发生在位于外部节点上一层的节点中，且有以下几种情况发生

1. 要插入的节点中关键码的数量小于 $m-1$，按大小排序直接插入该节点即可
2. 要插入的节点中关键码的数量等于 $m$，则我们需要将当前节点进行一个分裂，并将 $k_{\frac{m}{2}}$ 的关键码拉到父节点（这里的除法是 $m/2$ 向上取整）。如果父节点的关键码也满了，那么我们就递归分裂并向上移动关键码。
3. 如果root的关键码也是满的，那么这样递归向上会造成**B—Tree的高度加一**，这也是唯一的能够增加B-Tree高度的方式。当然，思考之后我们就会知道，其实能够到如此地步的概率一般是十分小的，在真实磁盘中的B-Tree的阶数一般都十分的大，即分裂一次之后我们可以在新的节点中存储很多的节点，因此不太有可能造成B—Tree的高度增加。即使高度增加了，那么下一次增加肯定会发生很久以后，因为此时我们有很多分裂的节点可以让我们插入新的节点。
4. ![](https://s2.loli.net/2021/12/24/1ar9AizCdyStoJ3.png)
2. ![](https://s2.loli.net/2021/12/24/QDoJLerMzvgCBa5.png)

节点的插入最多引起的磁盘访问量是 $h + 2s + 1$，h是树高，s是分裂的节点数量（需要写入分裂后的节点到磁盘），剩下1是写入新的节点

#### 3.3.4 B-Tree的删除

B-Tree的删除有两种情况：

1. 删除的关键码所在节点的子节点是一个外部节点，即删除的关键码在叶子节点中
2. 删除的关键码所在节点不是叶节点。

##### 3.3.4.1 Case 1（删除的关键码的子节点是一个外部节点）

1. 若删除该关键码之后该节点的关键码个数仍然大于 $\frac{m}{2} - 1$（这里的除法要向上取整），那么我们就直接删除该关键码即可

2. 如果不满足上述的情况，那么又可以分出两种情况：

	* 那么我们需要进行一个"借"的操作。对于一个关键码个数刚好是 $\frac{m}{2} - 1$的节点进行删除，我们可以向邻居借关键码，并进行一定的调整。

	* 调整方式：比如下图，需要从左边的邻居借一个关键码，将关键码**提到**父节点中，然后将父节点的关键码**下拉**到该节点中。

		![](https://s2.loli.net/2021/12/24/9hl53VFeWmD7X86.png)

	* 如果邻居节点也都只有 $\frac{m}{2} - 1$（除法向上取证）个节点，那么我们需要再删除之后合并两个子节点，而且将父节点在这两个子节点的指针之间的关键码**下拉**到子节点中。

	* 这样做有可能会在父节点造成新的合并（当下拉之后父节点与其邻居都不满足关键码数量至少有$\frac{m}{2} - 1$（除法向上取整）时 ），然后不断递归向上合并，最后有可能合并到根节点，此时B-Tree的**树高会减少一**

	* ![](https://s2.loli.net/2021/12/24/d2v36gSLW5Q9XbV.jpg)

##### 3.3.4.2 Case 2（删除的关键码不是一个叶子节点）

我们采用如下的步骤来进行处理（类似AVL树和二叉搜索树里的处理方式）

1. 删除该关键码
2. 用该关键码右边指针的子节点中**最小**的关键码**替代**该位置要被删除的关键码（这能保证该关键码右边指针的子节点中所有的关键码的值还是大于该关键码的） / 或者用该关键码左边指针的子节点中**最大**的关键码替代该位置要被删除的关键码
3. 因为最大 / 最小的关键码肯定在叶子节点中，所以我们回到了[case 1](#3.3.4.1 Case 1（删除的关键码的子节点是一个外部节点）)





## 4 优先级队列/堆





## 5 栈和队列



## 6 排序

### 6.1 快速排序

快速排序是我们平时用的最多的一种排序之一，虽然它是一种不稳定的排序方式，但其极高的效率和极小的空间复杂度让我们可以在很多场景下使用它。其时间复杂度为 $O(n \log n)$，是理论可以达到的排序算法的时间复杂度最低值，其采用了一种“分而治之”（divide and conquer）的思想。

#### 6.1.1 快速排序的基本步骤

快排中最为重要的就是**基准元**的选取，选取的好的基准元可以完美的处于当前要排序的数组的正中间，从而将数组完美的分成两半，这样就可以以“二分”的速度让数组不断缩小规模，然后对小数组进行排序从而完成大数组的排序。一般情况下，我们会选择第一个元素作为基准元，然后用两个**游标**来进行标记，我们的目标是将基准元换到某个位置`index`，使得基准元左边的元素全部小于基准元，基准元右边的元素全部大于基准元。

这时候上述的两个游标就发挥了用场，由于我们选取了第一个元素作为基准元，`int pivot = arr[i]`，所以`i`位置空缺了，我们将第二个游标`j`放到数组的最右边，然后让其向左遍历，遍历到比`pivot`小的元素我们就填充到`i`位置，然后开始移动`i`，不断让`i`移动直到遇到比`pivot`大的元素，然后就填充到`j`的位置上，如此不断循环直到`j >= i`，此时剩下的位置就是我们想要的`pivot`的位置，也是它最后的位置。然后就可以将其左边和右边的数组递归的进行如此步骤。

这么做的时间复杂度最优可以达到 $O(n \log n)$，即每次选取的基准元的位置都差不多在当前排序数组的正中间时，可以达到最优的情况。最坏的情况下我们仍然需要 $O(n^2)$ 的复杂度，比如我们每次选取的基准元都是当前数组中的最小值，那么在进行“二分”的时候，我们只能够有右数组而没有左数组。

快排是一种“分而治之”思想的体现，通过各种优化，可以成为我们日常使用的排序手段。在`Java`中，`Arrays.sort()`使用的就是快速排序，只不过是经过了一大重优化和变体的。



### 6.2 冒泡排序



### 6.3 插入排序



### 6.4 选择排序



### 6.5 堆排序



### 6.6 归并排序

